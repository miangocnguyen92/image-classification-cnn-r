#install.packages("torch")
#install.packages("luz")
#install.packages("torchvision")
library(torch)
library(luz)
library(torchvision)

# Function to transform images to tensor data structures
transform <- function(x) {
  transform_to_tensor(x)
}

# Download and transform the images from the CIFAR-100 database
train_ds <- cifar100_dataset(root="./", train=TRUE, download=TRUE, transform=transform)
test_ds <- cifar100_dataset(root="./", train=FALSE, transform=transform)

# For the first element: 
# first component is a three-dimension array (1:3) storing 32x32 values for 3 colors
# the second component is an integer which stores the actual category this image belong to
str(train_ds[1])

# The number of the images in the training set
length(train_ds)

# The number of images in the test set
length(test_ds)


setwd("C:/Users/ngocn/Desktop/OMSA/MGT6203/Week 15")
# "fine_label_names.txt" contains the names of all 100 fine categories
labels <- read.table("fine_label_names.txt")
labels <- labels$V1

# Display 100 categories => category 20th is the one that the first image is belong to "cattle"
labels[1:100]

# Display panel to 5 rows, 5 columns
par(mar=c(0,0,0,0), mfrow = c(5, 5))

# Display 20 images
for (i in 1:20)
  plot(as.raster(as.array(train_ds[i][[1]]$permute(c(2,3,1)))))

# Display 20 categories that those images belong to
# first code: retrieve the indices stored in the image data
cat.indx <- sapply(1:25, function(x) train_ds[x][[2]])
# second code: display corresponding text descriptions of these categories
matrix(labels[cat.indx],5,5, byrow=TRUE)

# Set up one Convolution-Polling cycle
# kernel_size = c(3,3): the size of convolution filter
# we first do the convolution, then apply relu activation, then do max pooling
conv_block <- nn_module(
  initialize = function(in_channels, out_channels) {
    self$conv <- nn_conv2d(
      in_channels = in_channels,
      out_channels = out_channels,
      kernel_size = c(3,3), # 3x3 convolution filter
      padding = "same"
    )
    self$relu <- nn_relu() # apply ReLU activation function
    self$pool <- nn_max_pool2d(kernel_size = c(2,2)) # 2x2 block pooling
  },
  forward = function(x) {
    x %>%
      self$conv() %>%
      self$relu() %>%
      self$pool()
  }
)

# Set up the CNN model
model <- nn_module(
  initialize = function() {
    self$conv <- nn_sequential ( #4 Convolution-Pooling cycles
      conv_block(3, 32),
      conv_block(32, 64),
      conv_block(64, 128),
      conv_block(128, 256)
    )
    self$output <- nn_sequential(
      nn_dropout(0,5),
      nn_linear(2*2*256, 512), # one more hidden layer before the output
      nn_relu(),
      nn_linear(512, 100)
    )
  },
  forward = function(x) {
    x %>%
      self$conv() %>%
      torch_flatten(start_dim = 2) %>%
      self$output()
  }
)

# Fit the CNN model
Sys.time()
fitted <- model %>%
  setup(
    loss = nn_cross_entropy_loss(),
    optimizer = optim_rmsprop,
    metrics = list(luz_metric_accuracy())
  ) %>%
  set_opt_hparams(lr = 0.001) %>%
  fit(
    train_ds,
    epochs = 30, # the number of epochs determine the amount of time it will take to complete the estimation routine
    valid_data = 0.2, # 20% test size
    dataloader_options = list(batch_size = 128)
  )
Sys.time()

# To load the pre-fitted CNN model I provided
fitted <- luz_load("cnn_cifar.Luz")

plot(fitted)

# out-of-sample Test
pred <- predict(fitted, test_ds)
pred.class <- torch_argmax(pred, dim=2)
pred.class <- as_array(pred.class)

true.class <- sapply(1:10000, function(x) test_ds[x][[2]])

# confusion matrix
# result 43% => good, because we have 100 categories, so 1 random guess only have 1% probability correct
confusion <- table(pred.class, true.class)
sum(diag(confusion)) / sum(confusion)

# Display some incorrect predicted images
wrong.list <- which(pred.class!=true.class)
wrong.list[1:100]

# Display 25 wrong images
par(mar=c(0,0,0,0), mfrow=c(5,5))
for (i in wrong.list[1:25])
  plot(as.raster(as.array(test_ds[i][[1]]$permute(c(2,3,1)))))

# Display true class of these 25 images
cat.indx <- true.class[wrong.list[1:25]]
matrix(labels[cat.indx],5,5, byrow=TRUE)

# Display the predicted class of these 25 images
# 5th image, the correct category is "tulip", but it predicted as "spider"
cat.indx <- pred.class[wrong.list[1:25]]
matrix(labels[cat.indx],5,5, byrow=TRUE)
